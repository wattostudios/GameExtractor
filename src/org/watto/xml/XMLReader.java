/*
 * Application:  WSProgram 4.0
 * Author:       wattostudios
 * Website:      http://www.watto.org
 * Copyright:    Copyright (c) 2004-2024 wattostudios
 *
 * License Information:
 * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
 * published by the Free Software Foundation; either version 2 of the License, or (at your option) any later versions. This
 * program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranties
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License at http://www.gnu.org for more
 * details. For further information on this application, refer to the authors' website.
 */

package org.watto.xml;

import java.io.File;

import org.watto.ErrorLogger;
import org.watto.io.FileManipulator;
import org.watto.io.Manipulator;
import org.watto.io.converter.ByteConverter;

/***********************************************************************************************
Reads an XML-format document into a tree of <code>XMLNode</code>s
<br /><br />
<b><i>OVERVIEW</i></b>
<br /><br />
These XML Utilities allow easy reading, writing, and manipulation of XML files. When reading a
file, it does not worry about things like DTDs and namespaces: all that it requires is that the
file conforms to the XML standard (such as attribute structure, correct closing of tags, etc.
<br /><br />
Comment tags <!-- --> and declaration tags <? ?> are all ignored, and will not appear in the tree
generated by the reader. Similarly, they are not written in the output.
<br /><br />
The reader an writer are static classes that allow you to read or write a file using a single
method call. They both work with the XMLNode class, which builds the tree structure and allows
traversal of the nodes. XMLNode implements TreeNode and MutableTreeNode so that the tree can
easily be used by other standard classes such as JTree.
<br /><br />
All file processing has a buffer behind it which allows for faster reading and writing. The
classes and methods are kept deliberately simple so that the code is easy to read and maintain.
All the classes also contain JavaDoc information and comments.
<br /><br />
The FileManipulator classes are the classes used to process files. These classes are independent
from these XML Utilities, and can easily be changed to use other classes with only very minor
code adjustment. The latest updates to the FileManipulator classes can be obtained from the
WATTO Studios website at http://www.watto.org , as can updates to these XML Utilities. The
FileManipulator classes are the underlying file processing classes behind all my programs written
since 2003, and have been tried and tested extensively in this period, so they should be pretty
stable. They are also released under the GPL license - see the FileManipulator class for more
details.
<br /><br />
<b><i>TODO</i></b>
<br /><br />
- Set the XML Writer to write the XML declaration tag at the start (via an option)

@see org.watto.xml.XMLNode
***********************************************************************************************/
public class XMLReader {

  /** The stream for reading the file **/
  protected static Manipulator manipulator = null;

  /** The currently-read character **/
  protected static char character;

  /** Whether the file is being read as Unicode or non-Unicode **/
  protected static boolean unicode = false;

  /***********************************************************************************************
  Reads an XML document <code>file</code> into a tree of <code>XMLNode</code>s
  @param file the XML document to read
  @return the tree of <code>XMLNode</code>s representing the XML document
  ***********************************************************************************************/
  public static XMLNode read(File file) {
    XMLNode root = new XMLNode();
    read(file, root);
    try {
      return root.getChild(0);
    }
    catch (Throwable t) {
      return root;
    }
  }

  /***********************************************************************************************
  Reads an XML document <code>file</code> into a tree of <code>XMLNode</code>s. The tree is
  constructed using the given <code>root</code> node
  @param file the XML document to read
  @param root the root node of the tree, into which the tree will be constructed
  ***********************************************************************************************/
  public static void read(File file, XMLNode root) {
    read(new FileManipulator(file, false), root);
  }

  /***********************************************************************************************
  Reads an XML-format <code>String</code> from a <code>Manipulator</code> into a tree of
  <code>XMLNode</code>s
  @param manipulator the <code>Manipulator</code> where the XML-format <code>String</code> is
  being read from
  @return the tree of <code>XMLNode</code>s representing the XML-format <code>String</code>
  ***********************************************************************************************/
  public static XMLNode read(Manipulator manipulator) {
    XMLNode root = new XMLNode();
    read(manipulator, root);
    try {
      return root.getChild(0);
    }
    catch (Throwable t) {
      return root;
    }
  }

  /***********************************************************************************************
  Reads an XML-format <code>String</code> from a <code>Manipulator</code> into a tree of
  <code>XMLNode</code>s. The tree is constructed using the given <code>root</code> node
  @param newManipulator the <code>Manipulator</code> where the XML-format <code>String</code> is
  being read from
  @param root the root node of the tree, into which the tree will be constructed
  ***********************************************************************************************/
  public static void read(Manipulator newManipulator, XMLNode root) {
    try {

      manipulator = newManipulator;

      // look for unicode header
      if (ByteConverter.unsign(manipulator.readByte()) == 255 && ByteConverter.unsign(manipulator.readByte()) == 254) {
        unicode = true;
      }
      else {
        unicode = false;
        manipulator.seek(0);
      }

      readTag(root);
      manipulator.close();
    }
    catch (Throwable t) {
      ErrorLogger.log(t);
    }
  }

  /***********************************************************************************************
  Reads an XML-format <code>String</code> into a tree of <code>XMLNode</code>s
  @param text the XML-format <code>String</code>
  @return the tree of <code>XMLNode</code>s representing the XML-format <code>String</code>
  ***********************************************************************************************/
  public static XMLNode read(String text) {
    XMLNode root = new XMLNode();
    read(text, root);
    try {
      return root.getChild(0);
    }
    catch (Throwable t) {
      return root;
    }
  }

  /***********************************************************************************************
  Reads an XML-format <code>String</code> into a tree of <code>XMLNode</code>s. The tree is
  constructed using the given <code>root</code> node
  @param text the XML-format <code>String</code>
  @param root the root node of the tree, into which the tree will be constructed
  ***********************************************************************************************/
  public static void read(String text, XMLNode root) {
    read(new FileManipulator(new org.watto.io.buffer.StringBuffer(text)), root);
  }

  /***********************************************************************************************
  Reads the attributes of the tag into the <code>root</code> node
  @param currentNode the tag that is having its attributes read.
  ***********************************************************************************************/
  public static void readAttributes(XMLNode currentNode) {
    try {

      //System.out.println("attributes");

      // loop that continues for all attributes
      while (character != '>' && character != '/') {

        while (character == ' ') {
          // Skip the ' ' between tag name and attribute, or between attributes
          readChar();
        }

        if (character == '/') {
          // the end of a single tag
          // could have attributes, but they are already read at this point
          return;
        }

        String key = "";
        String value = "";

        while (character != '=' && character != ' ' && character != '>' && character != '/') {
          key += character;
          readChar();
        }

        if (character == ' ' || character == '>' || character == '/') {
          // a single attribute rather than an key-value pair
        }
        else {
          // now need to read the value

          // read the character after the = sign
          readChar();

          if (character == '\"') {
            // skip the " character at the start of the value
            readChar();
          }

          while (character != '\"') {
            value += character;
            readChar();
          }

          // skip the " character at the end of the value
          readChar();

        }

        // now we have a complete attribute-value pair
        //value = new String(value.getBytes(), "UTF-8");
        currentNode.addAttribute(key, value);
        //System.out.println("    " + key + ":" + value);

      }

      // done reading the attributes

    }
    catch (Throwable t) {
      ErrorLogger.log(t);
    }
  }

  /***********************************************************************************************
  Reads the next <code>character</code> from the <code>manipulator</code>
  ***********************************************************************************************/
  public static void readChar() {
    try {
      if (unicode) {
        character = manipulator.readChar();
      }
      else {
        byte singleByte = manipulator.readByte();
        if (singleByte < 0) {
          // UTF-8
          int byteVal = ByteConverter.unsign(singleByte);

          byte[] utf8Bytes = null;
          if (byteVal >= 240) {
            // 4-bytes
            utf8Bytes = new byte[] { singleByte, manipulator.readByte(), manipulator.readByte(), manipulator.readByte() };
          }
          else if (byteVal >= 224) {
            // 3-bytes
            utf8Bytes = new byte[] { singleByte, manipulator.readByte(), manipulator.readByte() };
          }
          else if (byteVal >= 192) {
            // 2-bytes
            utf8Bytes = new byte[] { singleByte, manipulator.readByte() };
          }
          else {
            utf8Bytes = null;
          }

          if (utf8Bytes == null) {
            character = (char) singleByte;
          }
          else {
            character = new String(utf8Bytes, "UTF-8").charAt(0);
          }

        }
        else {
          character = (char) singleByte;
        }

        //System.out.println(character);
      }
    }
    catch (Throwable t) {
      ErrorLogger.log(t);
    }
  }

  /***********************************************************************************************
  Reads and discards a comment tag at the current position in the <code>manipulator</code>
  ***********************************************************************************************/
  public static void readComment() {
    try {

      //System.out.println("comment");

      while (character != '<') {
        if (manipulator.getOffset() >= manipulator.getLength()) {
          return;
        }

        readChar();

        if (character == '-') {
          readChar();
          if (character == '-') {
            readChar();
            if (character == '>') {
              // end of the comments
              return;
            }
          }
        }
      }

    }
    catch (Throwable t) {
      ErrorLogger.log(t);
    }
  }

  /***********************************************************************************************
  Reads and discards a declaration tag from the current position in the <code>manipulator</code>
  ***********************************************************************************************/
  public static void readDeclaration() {
    try {

      //System.out.println("declaration");

      readChar();

      while (character != '?') {
        readChar();
        if (character == '>') {
          // end of the declaration
          return;
        }
      }

    }
    catch (Throwable t) {
      ErrorLogger.log(t);
    }
  }

  /***********************************************************************************************
  Reads a single tag from the current position in the <code>manipulator</code>, adding it as a
  child to the <code>root</code> node
  @param root the root node to add this new tag to
  ***********************************************************************************************/
  public static void readTag(XMLNode root) {
    try {

      boolean keepReading = true; // true so that it enters the loop at least once

      //System.out.println("Tag");

      readChar();

      while (keepReading) {
        keepReading = false;

        if (character == '<') {
          readChar();
        }

        if (manipulator.getOffset() >= manipulator.getLength()) {
          return;
        }

        boolean endTag = false;
        if (character == '/') {
          endTag = true;
          readChar();
        }
        else if (character == '!') {
          readComment();

          readText(root);
          readTag(root);
          return;
        }
        else if (character == '?') {
          readDeclaration();

          readText(root);
          readTag(root);
          return;
        }

        String tag = "";

        while (character != '>' && character != ' ' && character != '/') {
          tag += character;
          readChar();
        }

        if (endTag) {
          // finished reading an end tag

          //System.out.println("Read an end tag: " + tag);
          // this tag is finished, so continue reading the text for the nodes parent
          readText((XMLNode) root.getParent());
          //readTag((XMLNode) root.getParent());
          return;
        }

        XMLNode node = new XMLNode(tag);
        root.addChild(node);

        if (character == ' ') {
          // tag has attributes - read them
          // also could be a single tag
          //System.out.println("Tag:" + tag);
          readAttributes(node);
        }

        // NOTE starts with an "if" in case readAttributes() above changes the character!
        if (character == '>') {
          // opening tag is finished

          // start reading the text
          //System.out.println("Read a start tag: " + tag);
          readText(node);
          readTag(node);

          if (character == '<') {
            keepReading = true; // need to keep reading the next tag
          }
        }
        else if (character == '/') {
          // a single tag

          // Skip the ">" character
          readChar();

          readText(node); // skip over the blanks
          if (character == '<') {
            keepReading = true; // need to keep reading the next tag
          }
          //readTag(root);
        }
        else {
          // ERROR

          return;
        }

        // done reading this tag
      }

    }
    catch (Throwable t) {
      ErrorLogger.log(t);
    }
  }

  /***********************************************************************************************
  Reads the content text of the <code>root</code> tag
  @param currentNode the tag that is having its contents read.
  ***********************************************************************************************/
  public static void readText(XMLNode currentNode) {
    try {

      if (currentNode == null) {
        return; // this only occurs for the root of the whole tree!
      }

      if (manipulator.getOffset() >= manipulator.getLength()) {
        return;
      }

      //System.out.println("text");

      if (character == '>') {
        readChar();
      }

      String text = "";

      boolean previousWhite = false;
      boolean checkAmpersand = false;
      while (character != '<') {
        if (manipulator.getOffset() >= manipulator.getLength()) {
          return;
        }

        if (character == '\n' || character == '\t' || character == '\r') {
          character = ' ';
        }

        if (character == ' ') {
          if (previousWhite) {
            // don't write duplicate white spaces
          }
          else {
            // write the single white space, and set up to detect duplicates
            previousWhite = true;
            text += character;
          }
        }
        else {

          if (character == '&') {
            checkAmpersand = true;
          }

          // write the normal text
          previousWhite = false;
          text += character;
        }

        readChar();
      }

      if (checkAmpersand) {
        // look for the &lt; and replace it
        text = text.replaceAll("&lt;", "<");
      }

      // add the text as a child on the current tag
      if (!text.equals("") && !(text.equals(" "))) {
        currentNode.addContent(text);
      }

      // 3.05 STACK OVERFLOW in newer VMs - moved out to previous level
      // readTag(currentNode);

      // done reading the text

    }
    catch (Throwable t) {
      ErrorLogger.log(t);
    }
  }

  /***********************************************************************************************
  Constructor
  ***********************************************************************************************/
  public XMLReader() {
  }
}